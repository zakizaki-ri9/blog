# 設計ドキュメントテンプレート

---
**目的**: 実装者間での一貫性を確保し、解釈のずれを防ぐために十分な詳細を提供する。

**アプローチ**:
- 実装の決定に直接情報を与える必須セクションを含める
- 実装エラーを防ぐために重要でない限り、オプションのセクションは省略する
- 機能の複雑さに詳細レベルを合わせる
- 長い散文よりも図や表を使用する

**警告**: 1000行に近づく場合は、設計の簡素化が必要な過度な機能の複雑さを示している可能性がある。
---

> セクションは、明確さが向上する場合、順序を変更してもよい（例：要件トレーサビリティを前に出す、データモデルをアーキテクチャの近くに移動する）。各セクション内では、レビュアーが一貫してスキャンできるよう **要約 → スコープ → 決定事項 → 影響/リスク** のフローを維持すること。

## 概要 (Overview)
最大2-3段落
**目的**: この機能は [ターゲットユーザー] に [特定の価値] を提供する。
**ユーザー**: [ターゲットユーザーグループ] は [特定のワークフロー] のためにこれを利用する。
**影響** (該当する場合): [特定の変更] によって現在の [システム状態] を変更する。

### 目標 (Goals)
- 主要目標 1
- 主要目標 2
- 成功基準

### 非目標 (Non-Goals)
- 明示的に除外される機能
- 現在のスコープ外の将来の考慮事項
- 延期された統合ポイント

## アーキテクチャ (Architecture)

> 詳細な調査ノートは背景として `research.md` のみを参照すること。すべての決定と契約をここでキャプチャし、レビュアーのために `design.md` を自己完結させる。
> 主要な決定をテキストでキャプチャし、構造的な詳細は図に任せる。同じ情報を散文で繰り返さないこと。

### 既存アーキテクチャ分析 (該当する場合)
既存システムを変更する場合:
- 現在のアーキテクチャパターンと制約
- 尊重すべき既存のドメイン境界
- 維持すべき統合ポイント
- 対処または回避された技術的負債

### アーキテクチャパターン & 境界マップ
**推奨**: 選択されたアーキテクチャパターンとシステム境界を示すMermaid図を含める（複雑な機能には必須、単純な追加には任意）

**アーキテクチャ統合**:
- 選択されたパターン: [名前と短い根拠]
- ドメイン/機能境界: [競合を避けるために責任がどう分離されるか]
- 維持された既存パターン: [主要なパターンをリスト]
- 新規コンポーネントの根拠: [なぜそれぞれが必要か]
- ステアリング準拠: [維持された原則]

### 技術スタック

| レイヤー | 選択 / バージョン | 機能における役割 | ノート |
|----------|-------------------|------------------|--------|
| フロントエンド / CLI | | | |
| バックエンド / サービス | | | |
| データ / ストレージ | | | |
| メッセージング / イベント | | | |
| インフラ / ランタイム | | | |

> ここの根拠は簡潔にし、より深さ（トレードオフ、ベンチマーク）が必要な場合は、短い要約に加え、参考資料 (Supporting References) セクションおよび `research.md` の生の調査ノートへのポインタを追加する。

## システムフロー (System Flows)

自明でないフローを説明するために必要な図のみを提供する。純粋なMermaid構文を使用すること。一般的なパターン:
- シーケンス（複数者間の相互作用）
- プロセス / 状態（分岐ロジックまたはライフサイクル）
- データ / イベントフロー（パイプライン、非同期メッセージング）

単純なCRUD変更の場合はこのセクションを完全にスキップする。
> フローレベルの決定（例：ゲート条件、リトライ）は、各ステップを再述するのではなく、図の後に簡潔に記述する。

## 要件トレーサビリティ (Requirements Traceability)

要件が複数のドメインにまたがる複雑またはコンプライアンスに敏感な機能にこのセクションを使用する。単純な1:1のマッピングはコンポーネント要約テーブルに頼ることができる。

各要件ID（例：`2.1`）を、それを実現する設計要素にマップする。

| 要件ID | 要約 | コンポーネント | インターフェース | フロー |
|--------|------|----------------|------------------|--------|
| 1.1 | | | | |
| 1.2 | | | | |

> 単一のコンポーネントが横断的な懸念なしに単一の要件を満たす場合のみ、このセクションを省略する。

## コンポーネントとインターフェース (Components and Interfaces)

コンポーネントごとの詳細に入る前に、クイックリファレンスを提供する。

- 要約はテーブルまたはコンパクトなリストにできる。例:
  | コンポーネント | ドメイン/レイヤー | 意図 | 要件カバレッジ | 主要な依存関係 (P0/P1) | 契約 |
  |----------------|-------------------|------|----------------|------------------------|------|
  | ExampleComponent | UI | XYZを表示 | 1, 2 | GameProvider (P0), MapPanel (P1) | Service, State |
- 新しい境界（例：ロジックフック、外部統合、永続化）を導入するコンポーネントのみ、完全な詳細ブロックが必要。単純なプレゼンテーションコンポーネントは、要約行と短い実装ノートに頼ることができる。

詳細ブロックをドメインまたはアーキテクチャレイヤーでグループ化する。各詳細コンポーネントについて、要件IDを `2.1, 2.3` としてリストする（「要件」は省略）。複数のUIコンポーネントが同じ契約を共有する場合、コードブロックを複製するのではなく、ベースインターフェース/Props定義を参照する。

### [ドメイン / レイヤー]

#### [コンポーネント名]

| フィールド | 詳細 |
|------------|------|
| 意図 | 責任の1行説明 |
| 要件 | 2.1, 2.3 |
| オーナー / レビュアー | (任意) |

**責任と制約**
- 主な責任
- ドメイン境界とトランザクションスコープ
- データ所有権 / 不変条件

**依存関係**
- Inbound: コンポーネント/サービス名 — 目的 (重要度)
- Outbound: コンポーネント/サービス名 — 目的 (重要度)
- External: サービス/ライブラリ — 目的 (重要度)

外部依存関係の調査結果をここに要約する。より深い調査（APIシグネチャ、レート制限、移行ノート）は `research.md` にある。

**契約**: Service [ ] / API [ ] / Event [ ] / Batch [ ] / State [ ]  ← 該当するもののみチェック。

##### サービスインターフェース
```typescript
interface [ComponentName]Service {
  methodName(input: InputType): Result<OutputType, ErrorType>;
}
```
- 事前条件:
- 事後条件:
- 不変条件:

##### API契約
| メソッド | エンドポイント | リクエスト | レスポンス | エラー |
|----------|----------------|------------|------------|--------|
| POST | /api/resource | CreateRequest | Resource | 400, 409, 500 |

##### イベント契約
- 発行イベント:
- 購読イベント:
- 順序 / 配信保証:

##### バッチ / ジョブ契約
- トリガー:
- 入力 / 検証:
- 出力 / 宛先:
- 冪等性 & 回復:

##### 状態管理
- 状態モデル:
- 永続化 & 一貫性:
- 同時実行戦略:

**実装ノート**
- 統合:
- 検証:
- リスク:

## データモデル (Data Models)

この機能で変更されるデータランドスケープの部分に焦点を当てる。

### ドメインモデル
- 集約とトランザクション境界
- エンティティ、値オブジェクト、ドメインイベント
- ビジネスルール & 不変条件
- 複雑な関係のための任意のMermaid図

### 論理データモデル

**構造定義**:
- エンティティ関係とカーディナリティ
- 属性とその型
- 自然キーと識別子
- 参照整合性ルール

**一貫性と整合性**:
- トランザクション境界
- カスケードルール
- 時間的側面（バージョニング、監査）

### 物理データモデル
**含めるタイミング**: 実装が特定のストレージ設計決定を必要とする場合

**リレーショナルデータベースの場合**:
- データ型を含むテーブル定義
- 主キー/外部キーと制約
- インデックスとパフォーマンス最適化
- スケールのためのパーティショニング戦略

**ドキュメントストアの場合**:
- コレクション構造
- 埋め込み vs 参照の決定
- シャーディングキー設計
- インデックス定義

**イベントストアの場合**:
- イベントスキーマ定義
- ストリーム集約戦略
- スナップショットポリシー
- プロジェクション定義

**Key-Value/ワイドカラムストアの場合**:
- キー設計パターン
- カラムファミリーまたは値構造
- TTLとコンパクション戦略

### データ契約 & 統合

**APIデータ転送**
- リクエスト/レスポンススキーマ
- 検証ルール
- シリアライズ形式（JSON, Protobufなど）

**イベントスキーマ**
- 発行されるイベント構造
- スキーマバージョニング戦略
- 後方/前方互換性ルール

**クロスサービスデータ管理**
- 分散トランザクションパターン（Saga, 2PC）
- データ同期戦略
- 結果整合性の処理

この機能に関連しないサブセクションはスキップする。

## エラー処理 (Error Handling)

### エラー戦略
各エラータイプに対する具体的なエラー処理パターンと回復メカニズム。

### エラーカテゴリと応答
**ユーザーエラー** (4xx): 無効な入力 → フィールドレベルの検証; 未承認 → 認証ガイダンス; 見つからない → ナビゲーションヘルプ
**システムエラー** (5xx): インフラ障害 → グレースフルデグラデーション; タイムアウト → サーキットブレーカー; 枯渇 → レート制限
**ビジネスロジックエラー** (422): ルール違反 → 条件の説明; 状態競合 → 移行ガイダンス

**プロセスフロー可視化** (複雑なビジネスロジックが存在する場合):
ビジネスワークフローを伴う複雑なエラーシナリオの場合のみMermaidフローチャートを含める。

### モニタリング
エラートラッキング、ロギング、およびヘルスモニタリングの実装。

## テスト戦略 (Testing Strategy)

### デフォルトセクション（ドメインに合わせて名前/セクションを調整）
- 単体テスト: コア関数/モジュールから3〜5項目（例：認証メソッド、購読ロジック）
- 統合テスト: 3〜5のコンポーネント間フロー（例：Webhook処理、通知）
- E2E/UIテスト (該当する場合): 3〜5の重要なユーザーパス（例：フォーム、ダッシュボード）
- パフォーマンス/負荷 (該当する場合): 3〜4項目（例：同時実行、高ボリューム操作）

## オプションセクション (該当する場合に含める)

### セキュリティ上の考慮事項
_認証、機密データ、外部統合、またはユーザー権限を扱う機能にこのセクションを使用する。この機能に固有の決定のみをキャプチャし、ベースライン制御についてはステアリングドキュメントに委ねる。_
- 脅威モデリング、セキュリティ制御、コンプライアンス要件
- 認証および認可パターン
- データ保護とプライバシーの考慮事項

### パフォーマンス & スケーラビリティ
_パフォーマンス目標、高負荷、またはスケーリングの懸念が存在する場合にこのセクションを使用する。機能固有の目標またはトレードオフのみを記録し、一般的な実践についてはステアリングドキュメントに頼る。_
- 目標メトリクスと測定戦略
- スケーリングアプローチ（水平/垂直）
- キャッシュ戦略と最適化技術

### 移行戦略
スキーマ/データの移動が必要な場合に移行フェーズを示すMermaidフローチャートを含める。
- フェーズ内訳、ロールバックトリガー、検証チェックポイント

## 参考資料 (Supporting References - Optional)
- 本文に情報を保持すると可読性が損なわれる場合（例：非常に長いTypeScript定義、ベンダーオプションマトリクス、網羅的なスキーマテーブル）にのみこのセクションを作成する。設計を自己完結させるために、意思決定のコンテキストはメインセクションに保持すること。
- 大きなスニペットをインライン化するのではなく、本文から参考資料へリンクする。
- 背景調査ノートと比較は引き続き `research.md` に残すが、その結論はメイン設計で要約する必要がある。