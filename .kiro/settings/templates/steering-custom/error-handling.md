# エラー処理標準

[目的: エラーの分類、形成、伝播、ログ記録、および監視方法の統一]

## 哲学
- 可能な限りフェイルファスト; システム境界でグレースフルにデグレードする
- スタック全体で一貫したエラー形状（人間 + 機械可読）
- ソース近くで既知のエラーを処理; 未知のエラーをグローバルハンドラに浮上させる

## 分類 (ソースによる処理決定)
- クライアント: 入力/検証/ユーザーアクションの問題 → 4xx
- サーバー: システム障害/予期しない例外 → 5xx
- ビジネス: ルール/状態違反 → 4xx (例: 409)
- 外部: サードパーティ/ネットワーク障害 → コンテキスト付きで 5xx または 4xx にマップ

## エラー形状 (単一の正規フォーマット)
```json
{
  "error": {
    "code": "ERROR_CODE",
    "message": "人間が読めるメッセージ",
    "requestId": "trace-id",
    "timestamp": "ISO-8601"
  }
}
```
原則: 安定したコード列挙型、シークレットなし、トレース情報を含める。

## 伝播 (どこで変換するか)
- APIレイヤー: ドメインエラー → HTTPステータス + 正規ボディ に変換
- サービスレイヤー: 型付きビジネスエラーをスローし、文字列型のエラーを避ける
- データ/外部レイヤー: 安全でアクション可能なコードでプロバイダーエラーをラップする
- 未知のエラー: グローバルハンドラにバブルアップ → 500 + 汎用メッセージ

パターン例:
```typescript
try { return await useCase(); }
catch (e) {
  if (e instanceof BusinessError) return respondMapped(e);
  logError(e); return respondInternal();
}
```

## ロギング (ノイズよりコンテキスト)
ログ: 操作、userId（あれば）、コード、メッセージ、スタック、requestId、最小限のコンテキスト。
ログ不可: パスワード、トークン、シークレット、完全なPII、機密データを含む完全なボディ。
レベル: ERROR（障害）、WARN（回復可能/エッジ）、INFO（主要イベント）、DEBUG（診断）。

## リトライ (安全な場合のみ)
リトライする場合: ネットワーク/タイムアウト/一時的な5xx かつ 操作が冪等である場合。
リトライしない場合: 4xx、ビジネスエラー、非冪等フロー。
戦略: 指数バックオフ + ジッター、試行回数制限; 冪等性キーを要求する。

## モニタリング & ヘルス
追跡: コード/カテゴリ別のエラー率、レイテンシ、飽和度; スパイク/SLI違反でのアラート。
ヘルス公開: `/health` (live), `/health/ready` (ready)。エラーをトレースにリンクする。

---
_パターンと決定に焦点を当てる。実装詳細や網羅的なリストなし。_