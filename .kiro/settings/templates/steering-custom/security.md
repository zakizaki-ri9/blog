# セキュリティ標準

[目的: 検証、認可、シークレット、およびデータのためのパターンによるセキュリティ態勢の定義]

## 哲学
- 多層防御; 最小特権; デフォルトで安全; フェイルクローズ
- 境界での検証; コンテキストに応じたサニタイズ; 入力を決して信頼しない
- 認証（誰か）と認可（何か）の分離

## 入力 & 出力
- API境界とUIフォームで検証; 型と制約を強制する
- 宛先（HTML, SQL, Shell, Logs）に基づいてサニタイズ/エスケープする
- ブロックリストより許可リストを優先する; 最小限の詳細で早期に拒否する

## 認証 & 認可
- 認証: 身元を確認; 短命なトークン/セッションを発行する
- 認可: アクションの前に権限を確認; デフォルトで拒否する
- ポリシーを一元化; コード全体でのチェックの重複を避ける

パターン:
```typescript
if (!user.hasPermission('resource:action')) throw ForbiddenError();
```

## シークレット & 設定
- シークレットを決してコミットしない; シークレットマネージャーまたはenvに保存する
- 定期的にローテーション; アクセス監査; 最小スコープ
- 起動時に必須環境変数を検証する; 欠落時はフェイルファスト

## 機密データ
- 収集を最小化; ログでのマスク/秘匿; 保存時および転送時の暗号化
- ロール/知る必要性によるアクセス制限; 機密レコードへのアクセス追跡

## セッション/トークンセキュリティ
- 可能な場所での httpOnly + secure cookies; どこでもTLS
- 短い有効期限; リフレッシュ時のローテーション; ログアウト/侵害時の失効
- トークンをオーディエンス/発行者にバインドする; 最小限のクレームを含める

## ロギング (セキュリティ認識)
- 認証試行、権限拒否、および機密操作をログに記録する
- パスワード、トークン、シークレット、完全なPIIを決してログに記録しない; 完全なボディを避ける
- イベントを相関させるために requestId とコンテキストを含める

## ヘッダー & トランスポート
- TLSの強制; HSTS
- セキュリティヘッダーの設定 (CSP, X-Frame-Options, X-Content-Type-Options)
- 最新の暗号化を優先する; 弱いプロトコル/暗号を無効化する

## 脆弱性態勢
- 安全なライブラリを優先する; 依存関係を最新に保つ
- CIでの静的/動的スキャン; 追跡と修正
- 一般的なクラスについてチームを教育する; 上記のパターンとしてコード化する

---
_パターンと原則に焦点を当てる。具体的な設定は運用ドキュメントにリンクする。_