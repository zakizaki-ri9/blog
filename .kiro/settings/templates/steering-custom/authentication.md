# 認証 & 認可標準

[目的: 認証モデル、トークン/セッションライフサイクル、権限チェック、およびセキュリティの統一]

## 哲学
- 明確な分離: 認証（誰か） vs 認可（何か）
- デフォルトで安全: 最小特権、フェイルクローズ、短命トークン
- UX配慮: リスクが高い場所ではフリクション、それ以外はスムーズに

## 認証

### メソッド (選択 + 根拠)
- オプション: JWT, Session, OAuth2, ハイブリッド
- 選択: [私たちのメソッド] 理由は [理由]

### フロー (高レベル)
```
1) ユーザーが身元を証明する（資格情報またはプロバイダー）
2) サーバーが検証し、トークン/セッションを発行する
3) クライアントがリクエストごとにトークンを送信する
4) サーバーがトークンを検証し、処理を進める
```

### トークン/セッションライフサイクル
- ストレージ: httpOnly Cookie または Authorization ヘッダー
- 有効期限: 短命なアクセス、より長いリフレッシュ（使用する場合）
- リフレッシュ: トークンをローテーションする; 失効を尊重する
- 失効: ログアウト/侵害時にブラックリスト/ローテーション

### セキュリティパターン
- TLSを強制する; 回避可能な場合はトークンをJSに決して公開しない
- トークンをオーディエンス/発行者にバインドする; 最小限のクレームを含める
- 敏感なアクションにはデバイスバインディングとIP/リスクチェックを検討する

## 認可

### 権限モデル
- 1つ選択: RBAC / ABAC / 所有権ベース / ハイブリッド
- ロール/属性を一元的に定義する; コードベース全体でのハードコードを避ける

### チェック (どこで強制するか)
- ルート/ミドルウェア: 粗い粒度のゲート
- ドメイン/サービス: 細かい粒度の決定
- UI: 条件付きレンダリング（セキュリティ依存なし）

パターン例:
```typescript
requirePermission('resource:action'); // route
if (!user.can('resource:action')) throw ForbiddenError(); // domain
```

### 所有権
- パターン: 所有者 または 特権ロールが実行可能
- 変更前にエンティティ境界で検証する

## パスワード & MFA
- パスワード: 強力なポリシー、ハッシュ化 (bcrypt/argon2)、平文不可
- リセット: 時間制限付きトークン、ワンタイム、ユーザーへの通知
- MFA: リスクの高い操作のためのステップアップ（ポリシー駆動）

## API間認証
- APIキーまたはOAuthクライアント資格情報を使用する
- キーのスコープを最小限にする; ローテーションと使用状況の監査
- ID（ユーザー/キー）によるレート制限

---
_パターンと決定に焦点を当てる。ライブラリ固有のコードなし。_