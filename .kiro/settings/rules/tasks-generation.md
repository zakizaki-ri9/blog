# タスク生成ルール

## コア原則

### 1. 自然言語による記述 (Natural Language Descriptions)
コード構造ではなく、能力と成果に焦点を当てる。

**記述すること**:
- 実現すべき機能性
- ビジネスロジックと振る舞い
- 機能と能力
- ドメイン用語と概念
- データ関係とワークフロー

**避けること**:
- ファイルパスとディレクトリ構造
- 関数/メソッド名とシグネチャ
- 型定義とインターフェース
- クラス名とAPI契約
- 具体的なデータ構造

**根拠**: 実装の詳細（ファイル、メソッド、型）は `design.md` で定義されている。タスクは行われるべき機能的な作業を記述する。

### 2. タスクの統合と進行 (Task Integration & Progression)

**すべてのタスクは以下を満たす必要がある**:
- 前の成果物の上に構築する（孤立したコードにしない）
- システム全体に接続する（ぶら下がった機能にしない）
- 段階的に進行する（複雑さが急激に飛ばない）
- シーケンスの早い段階でコア機能を検証する
- `design.md`（アーキテクチャパターン＆境界マップ）で定義されたアーキテクチャ境界を尊重する
- `design.md` に文書化されたインターフェース契約を遵守する
- 主要タスクの要約は控えめに使用する。作業が子タスクで完全に把握できる場合は、詳細な箇条書きを省略する。

**すべてをつなぎ合わせる統合タスクで終了する**。

### 3. 柔軟なタスクサイジング (Flexible Task Sizing)

**ガイドライン**:
- **主要タスク**: 論理的に必要なだけサブタスクを持つ（凝集度でグループ化）
- **サブタスク**: 各1〜3時間、サブタスクあたり3〜10個の詳細項目
- 細かすぎることと広すぎることのバランスをとる

**任意の数字を強制しない** - 論理的なグループ化で構造を決定させる。

### 4. 要件マッピング (Requirements Mapping)

**各タスク詳細セクションの最後を以下で締めくくる**:
- `_Requirements: X.X, Y.Y_`: **数値の要件IDのみ**をリストする（カンマ区切り）。説明的なテキスト、括弧、翻訳、または自由形式のラベルを決して追加しないこと。
- 横断的な要件の場合、関連するすべての要件IDをリストする。`requirements.md` 内のすべての要件は数値IDを持たなければならない。IDが欠落している場合は、タスクを生成する前に停止して `requirements.md` を修正する。
- 役立つ場合は `design.md` のコンポーネント/インターフェースを参照する（例：`_Contracts: AuthService API_`）

### 5. コードのみに焦点 (Code-Only Focus)

**以下のみを含める**:
- コーディングタスク（実装）
- テストタスク（単体、統合、E2E）
- 技術的なセットアップタスク（インフラ、設定）

**以下を除外する**:
- デプロイメントタスク
- ドキュメンテーションタスク
- ユーザーテスト
- マーケティング/ビジネス活動

### オプションのテストカバレッジタスク

- 設計がすでに機能的カバレッジを保証しており、迅速なMVP配信が優先される場合、純粋にテスト指向のフォローアップ作業（例：ベースラインレンダリング/単体テスト）は `- [ ]*` チェックボックス形式を使用して **オプション** としてマークする。
- サブタスクが詳細箇条書きで `requirements.md` の受け入れ基準を直接参照している場合にのみ、オプションマーカーを適用する。
- 実装作業や統合に不可欠な検証を決してオプションとしてマークしないこと。`*` はMVP後に再訪可能な補助的/延期可能なテストカバレッジのために予約する。

## タスク階層ルール

### 最大2レベル
- **レベル1**: 主要タスク (1, 2, 3, 4...)
- **レベル2**: サブタスク (1.1, 1.2, 2.1, 2.2...)
- **これ以上深くネストしない** (1.1.1 は不可)
- 主要タスクが単一のアクション可能な項目しか含まない場合は、構造を折りたたみ、サブタスクを主要レベルに昇格させる（例：`1.1` を `1.` に置き換える）。
- 主要タスクが単なるコンテナとして存在する場合は、チェックボックスの説明を簡潔に保ち、詳細な箇条書きの重複を避ける。詳細はサブタスクに残す。

### 連続番号付け
- 主要タスクは必ず増加する: 1, 2, 3, 4, 5...
- サブタスクは主要タスクごとにリセットされる: 1.1, 1.2, その後 2.1, 2.2...
- 主要タスク番号を決して繰り返さない

### 並行分析（デフォルト）
- 明示的に無効化（例：`--sequential` フラグ）されない限り、並行分析が有効であると想定する。
- **すべて** の条件が成り立つ場合、並行して実行可能なタスクを特定する:
  - 保留中の他のタスクへのデータ依存がない
  - 競合するファイルや共有リソースの競合がない
  - 別のタスクからの事前のレビュー/承認が必要ない
- 特定された並行タスクが、アーキテクチャパターン＆境界マップで定義された別々の境界内で動作することを検証する。
- `design.md` のAPI/イベント契約が、競合を引き起こすような形で重複していないことを確認する。
- 資格のある各タスクの数値識別子の直後に `(P)` を追加する:
  - 例: `- [ ] 2.1 (P) メールのバックグラウンドワーカーを構築する`
  - 適切な場合、主要タスクとサブタスクの両方に適用する。
- シーケンシャルモードが要求された場合、`(P)` マーカーを完全に省略する。
- 並行タスクを論理的にグループ化し（可能な場合は同じ親の下）、順序付けの注意点があれば詳細箇条書きで強調する。
- タスクが似ていても `(P)` を妨げる依存関係がある場合は、明示的に指摘する。

### チェックボックスフォーマット
```markdown
- [ ] 1. 主要タスクの説明
- [ ] 1.1 サブタスクの説明
  - 詳細項目 1
  - 詳細項目 2
  - _Requirements: X.X_

- [ ] 1.2 サブタスクの説明
  - 詳細項目...
  - _Requirements: Y.Y_

- [ ] 1.3 サブタスクの説明
  - 詳細項目...
  - _Requirements: Z.Z, W.W_

- [ ] 2. 次の主要タスク (1を繰り返さない!)
- [ ] 2.1 サブタスク...
```

## 要件カバレッジ

**必須チェック**:
- requirements.md の **すべて** の要件がカバーされている必要がある
- すべての要件IDをタスクマッピングと相互参照する
- ギャップが見つかった場合: 要件または設計フェーズに戻る
- 対応するタスクのない要件を残してはならない

`requirements.md` のトップレベル要件番号を `N` として、`N.M` 形式の数値要件IDを使用し（例：要件1 → 1.1, 1.2; 要件2 → 2.1, 2.2）、`M` はその要件グループ内のローカルインデックスとする。

意図的に延期された要件があれば、その根拠とともに文書化する。